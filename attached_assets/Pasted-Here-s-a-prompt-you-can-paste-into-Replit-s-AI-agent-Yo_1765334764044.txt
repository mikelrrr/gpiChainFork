Here’s a prompt you can paste into Replit’s AI agent:

---

You are an expert full-stack engineer and architect.
You are working inside Replit and your job is to **design and implement an MVP web application** with a clear data model, backend API, and frontend UI.

## High-level product vision

Build a **party / community access app** that manages:

1. A **GPI chain** (who invited whom) using invite links.
2. A **level system** (1–5) for users, with promotion workflows and voting.
3. A simple **admin dashboard** to see:

   * Who is in each level.
   * Who invited whom.
   * Promotion requests and vote results.

The app is not just for one event; think of it as a **lightweight membership system** for a creative HQ / community where access is by invitation and reputation is modeled through levels.

---

## Technical preferences

* Use a modern, maintainable stack appropriate for Replit:

  * **Backend:** Node.js with TypeScript (Express, NestJS, or tRPC – choose what fits best in Replit).
  * **Frontend:** React (if easy in Replit) or a simple server-rendered approach.
  * **Database:** Postgres or a Replit-compatible SQL DB via an ORM like Prisma (preferred).
* Structure the project cleanly:

  * Separate concerns: models, services, routes/controllers, UI.
  * Make it easy to extend later (e.g., to add chatbots, tokenomics, etc.).

If Replit has template preferences, pick the option that best supports a **full-stack web app with a persistent database**.

---

## Core domain concepts & data model (MVP)

Design a schema that at least includes:

1. **User**

   * `id` (primary key)
   * `name` (or handle)
   * `email` (unique)
   * `password_hash`
   * `level` (integer 1–5; default = 1)
   * `invited_by_user_id` (nullable FK → User.id)
   * `created_at`
   * `updated_at`
   * `status` (e.g., active, suspended, expelled)
   * `agreement_accepted_at` (timestamp)
   * `agreement_version` (string or int)

2. **InviteLink**

   * `id`
   * `token` (unique string, used in URLs – secure/random)
   * `invited_by_user_id` (FK → User.id)
   * `max_uses` (nullable; null = unlimited)
   * `uses_count` (int, default 0)
   * `status` (active / disabled / expired)
   * `created_at`
   * `used_by_user_id` (optional, if we decide 1 link = 1 user)

3. **PromotionRequest**

   * `id`
   * `candidate_user_id` (FK → User.id)
   * `current_level`
   * `proposed_level`
   * `created_by_user_id` (FK → User.id – who initiated the request)
   * `status` (open / approved / rejected / expired)
   * `required_votes` (int)
   * `allowed_voter_min_level` (e.g., 4 – only level 4+ can vote)
   * `deadline` (nullable timestamp)
   * `justification` (text)
   * `created_at`
   * `updated_at`

4. **Vote**

   * `id`
   * `promotion_request_id` (FK → PromotionRequest.id)
   * `voter_user_id` (FK → User.id)
   * `vote` (enum: “for” / “against”)
   * `comment` (nullable)
   * `created_at`

5. **UserLevelHistory** (optional but ideal)

   * `id`
   * `user_id` (FK → User.id)
   * `previous_level`
   * `new_level`
   * `changed_by_user_id` (FK → User.id, nullable if system-driven)
   * `reason` (text, e.g., “promotion approved”, “direct change by Level 5”)
   * `created_at`

You can refine/extend this schema, but keep it simple and consistent with the flows below.

---

## Functional flows to implement (MVP)

### 1. Initial admin / Level 5 setup

* On first run (empty DB), create a flow to register the **first user** as **Level 5**.
* That user becomes the initial “Núcleo / core admin”.

Flow:

1. If there are **no users** in the DB:

   * Show a **“Create first admin user”** page.
2. Form fields: name, email, password.
3. On submit:

   * Create user with `level = 5`.
   * Log them in.
   * Redirect to admin dashboard.

---

### 2. Authentication

Implement basic authentication:

* **Registration** (via invite link only; see below).
* **Login** (email + password).
* Passwords must be **hashed**.
* Keep it simple:

  * Session-based auth or JWT-based auth – whichever is easier in Replit.
* Provide a minimal middleware/helper to:

  * Identify the authenticated user.
  * Enforce role checks (e.g., Level 4+ only).

---

### 3. Generating invite links (GPI chain)

Any logged-in user should be able to generate invite links. Later we can restrict this by level; for now, assume any user can invite.

Flow:

1. **Page: “Invite people”** (requires login).
2. Show:

   * Count of people this user has already invited.
   * Table of their invites (optional for MVP).
3. Button: **“Generate new invite link”**.
4. On click:

   * Create an `InviteLink` with:

     * `invited_by_user_id` = current user.
     * `token` = secure random string.
     * `max_uses` = 1 by default (fine for MVP).
     * `uses_count` = 0.
     * `status` = active.
5. Return a URL like:
   `https://<app-domain>/register?invite=<token>`.
6. On the UI:

   * Display the URL so the user can copy it.
   * Optionally, provide a field for entering an email and send it from the backend (if trivial).

---

### 4. Registration via invite link (GPI chain binding)

Registration **must** be through a valid invite link.

Flow:

1. Anonymous user visits `/register?invite=<token>`.
2. Backend validates the token:

   * Exists.
   * Status is active.
   * `max_uses` not exceeded (if set).
3. If invalid:

   * Show an error page: “This invitation link is not valid or has expired.”
4. If valid:

   * Show a registration form:

     * “You were invited by: <inviter name/handle>.”
     * Fields: name/handle, email, password.
     * Terms & Conditions / Agreement text (placeholder for now).
     * Required checkbox: “I have read and accept the agreement.”
5. On submit:

   * Validate inputs.
   * **Require** the “I agree” checkbox.
   * Create a `User` row:

     * `name`, `email`, `password_hash`.
     * `level = 1` (default).
     * `invited_by_user_id` = inviter.
     * `agreement_accepted_at` = now.
     * `agreement_version` = 1 (hardcoded for now).
   * Increment `InviteLink.uses_count`.
   * Optionally set `InviteLink.status` to used/disabled if max_uses reached.
   * Log the user in and redirect to their dashboard.

---

### 5. Dashboard: Users by level

Create a simple dashboard with:

* A **“Users by level”** view:

  * For each level 1–5:

    * Show list of users:

      * Name/handle.
      * Email.
      * Who invited them.
      * Date joined.
      * Number of people they invited (optional: calculated query).
* Filters:

  * Filter by level.
  * Search by name/handle/email (simple contains search is fine).

This is essentially a **table UI** with some filters.

---

### 6. GPI chain visualization (MVP)

We don’t need a fancy graph library yet. For the MVP:

* Create a **“My network”** page for each logged-in user:

  * Show:

    * Who invited me (if any).
    * Whom I have invited (list of users).
* Also, a simple **admin view**:

  * For Level 4+ users, show:

    * A page where you can select a user and see:

      * Their inviter.
      * Their invitees.
  * This can be represented as a simple tree-like structure or nested list.

If it’s easy, you can use a simple tree layout or indentation for nested invites.

---

### 7. Promotion requests & voting

We need a promotion mechanism where higher-level users vote to promote others.

Assumptions (for MVP):

* Promotions are needed for level raises, e.g.:

  * 1 → 2
  * 2 → 3
  * 3 → 4
* Only **Level 4 or 5** users can **create** promotion requests.
* Only **Level 4 or 5** users can **vote**.
* A promotion is approved if it reaches a minimum number of **“for”** votes (e.g., 3 votes).

#### 7.1 Creating a promotion request

Flow:

1. A Level 4 or 5 user navigates to another user’s profile.
2. There is a button: **“Propose level promotion”**.
3. On click, show a form:

   * Show current level (read-only).
   * Select proposed level (must be higher than current).
   * Text area for justification.
   * Optionally show: “This promotion needs 3 votes from Level 4+ users.”
4. On submit:

   * Create a `PromotionRequest` row:

     * `candidate_user_id`
     * `current_level`
     * `proposed_level`
     * `created_by_user_id`
     * `status = 'open'`
     * `required_votes = 3` (hardcode for now)
     * `allowed_voter_min_level = 4`
     * `deadline` = null (MVP, no deadline logic yet)
     * `justification`
   * Optionally notify Level 4+ users (for now, just list it in a "Pending promotions" view).

#### 7.2 Voting on a promotion

Flow:

1. Any user with `level >= 4` can see a **“Pending promotions”** page.
2. This page lists all `PromotionRequest` with `status = 'open'`:

   * Candidate, current level, proposed level, created by, created_at, justification.
3. Clicking a specific request opens a detail page:

   * Shows candidate details and existing votes.
4. The voter (Level 4+) can cast a vote:

   * Buttons:

     * “Vote FOR promotion”
     * “Vote AGAINST promotion”
   * Optional comment field.
5. On submit:

   * Create a `Vote` row for this promotion request & voter.
   * Prevent the same user from voting twice on the same request.
   * Recompute counts of votes `for` and `against`.

#### 7.3 Auto-approving the promotion

* After each new vote:

  * Recount all votes for that `PromotionRequest`.
  * If **number of “for” votes ≥ required_votes**:

    * Set `PromotionRequest.status = 'approved'`.
    * Update the `User.level` of the candidate to `proposed_level`.
    * Create a `UserLevelHistory` record with the promotion details.
* We don’t need complex expiry/deadline logic for MVP.

---

### 8. Direct level changes (admin only)

For emergency or manual control:

* Allow Level 5 users to **directly change** another user’s level without a promotion request.
* Flow:

  1. Level 5 user opens a user’s profile page.
  2. There is a button **“Change level directly (Admin)”**.
  3. On click, show:

     * Current level.
     * Dropdown for new level.
     * Required text reason.
  4. On submit:

     * Update `User.level`.
     * Insert into `UserLevelHistory` with `changed_by_user_id` = the admin.
* This action should be clearly labeled as an admin override in the UI.

---

## Non-functional requirements

* Keep code readable and well structured. Add comments for key flows.
* Provide simple **seed scripts or endpoints** for development (e.g., quickly create users for testing).
* Make it straightforward to later:

  * Integrate a chatbot (e.g., via API route).
  * Swap or configure the database connection.
  * Add more roles/permissions.

---

## How to proceed as Replit Agent

1. **Design the database schema** (Prisma or equivalent).
2. **Set up the backend**:

   * Auth routes.
   * Invite link routes.
   * Promotion/voting routes.
   * Basic role-based middleware.
3. **Set up the frontend** pages:

   * First admin registration (if DB empty).
   * Login page.
   * Invite page.
   * Register via invite page.
   * Users-by-level dashboard.
   * My network / GPI chain (simple).
   * Promotion request list and detail.
   * User profile page (with promotion / change level buttons for authorized users).
4. Provide instructions in a README on:

   * How to run the app.
   * How to seed the DB.
   * How to log in as the initial Level 5 user.

If you need to make assumptions (e.g., about UI library, exact DB), choose what integrates best with Replit, but keep everything clean and extensible.

---

Use this spec as the source of truth. If something is ambiguous, make a reasonable assumption and document it in comments or the README.
