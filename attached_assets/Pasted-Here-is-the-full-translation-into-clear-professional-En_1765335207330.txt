Here is the full translation into clear, professional English:

---

## **1.3. Main Functional Flows**

### **1.3.1. User Registration via Invitation Link**

**Requirements:**

* A user who is already registered can generate a unique invitation link.
* The link must securely include the information of who is inviting:

  * Example: a unique token associated with `invited_by_user_id`.
* When the invitee opens the link, they should see:

  * A registration screen (name/handle, email, etc.).
  * The name of the host/inviter (for transparency).
  * The agreement / terms & conditions text.
* The user cannot complete registration without accepting (“I agree”) the terms.
* Once registration is completed:

  * The new user is created with a default level (e.g., Level 1, configurable).
  * The relationship is recorded:

    * `invited_by = <ID of the user who generated the link>`
  * The date and time of the agreement acceptance are stored (for traceability).

---

### **1.3.2. Management of the GPI Chain (who invited whom)**

**Requirements:**

* The system must maintain an **invitation graph**:

  * For each user: know who invited them (parent) and whom they have invited (children).
* The system must allow querying:

  * The invitation tree starting from any user.
  * The complete invitation chain from the root level to any node.
* The system must include a **visual interface** for the GPI chain. Example views:

  * **Tree/organizational chart view** (like a family tree).
  * **Graph of nodes and edges**:

    * Each node = user (icon + level).
    * Node color or shape = level (1–5).
    * Hover/click shows basic user data (name, level, who invited them, etc.).
  * **Table view**:

    * Columns: user, level, invited by, number of invitees, registration date, etc.
* Filtering and search:

  * Filter by level.
  * Search by name/handle/email.
  * Optional: filter by registration date (last week, last month, etc.).

---

### **1.3.3. Visualization of Users by Level**

**Requirements:**

* “Users by Level” view:

  * For each level (1–5), show a list of users.
  * Metrics: number of users per level, percentage of total users.
* Must allow:

  * Sorting by name, registration date, number of invitees, etc.
* Clicking on a user should show:

  * Basic profile.
  * Their GPI chain (who invited them and whom they have invited).

---

### **1.3.4. Level Management by Level 4 and Level 5 Users**

**Requirements:**

Users with Level 4 and Level 5 must be able to:

* Propose a change of level for a user (promotion or demotion) according to predefined rules.

Assignment options:

* **Direct assignment** (e.g., Level 5 can change a level without a vote, if defined by policy).
* **Vote-based proposal** (see next section).

Every level change must:

* Be saved in an administrative audit log including:

  * Affected user.
  * Previous level / new level.
  * Date.
  * Who executed it / which vote approved it.
  * Reason (text field).

---

### **1.3.5. Voting System for Level Promotion**

**Requirements:**

For certain promotions (e.g., from Level 2 → Level 3, or Level 3 → Level 4), the system requires:

* A promotion proposal created by an authorized user (e.g., Level 4 or Level 5).

Configurable parameters per promotion type:

* Who can vote (only Levels 4 and 5, or Levels 3+, etc.).
* Minimum number of votes required to approve.
* Optional voting deadline.

**Voting flow:**

* A **Promotion Request** is created with:

  * Candidate user.
  * Current level and proposed level.
  * Justification.
* Users eligible to vote receive:

  * Internal notification and/or email.
* Each voter may choose:

  * “For”, “Against” (and optionally a comment).
* The system calculates:

  * Total votes “For” / “Against”.
* When the approval criteria are met (e.g., 3 positive votes from Level 4 or 5):

  * The level change is executed automatically.
  * The action is recorded in the audit log.

**The interface must allow:**

* Viewing open promotion requests.
* Viewing the history of promotions and voting results.

---

## **1.4. Non-Functional Requirements**

### **Authentication and Security**

* Login with email + password (minimum).
* Optional: Magic links, OAuth (Google/Apple), etc.
* Password encryption (bcrypt or similar).
* Invitation tokens must be signed/secure (JWT or another mechanism).

### **Persistence and Consistency**

* Relational database (due to hierarchical nature and relationships).
* Referential integrity between users and invitations.

### **Scalability**

* Must support hundreds/thousands of users and their GPI chain.
* Optimized queries for tree/graph-style invitation structures.

### **Auditability**

* Administrative actions log:

  * Level changes.
  * Creation/closure of promotion votes.
  * Modifications to voting parameters.

### **Usability**

* Clear, mobile-friendly UI.
* Intuitive visual interfaces for exploring the GPI chain.

### **Maintainability**

* Code organized into layers (frontend, backend, data).
* Key configurations (voting parameters, initial levels, etc.) should be easily modifiable without redeploying the entire app.

---

If you want, I can also provide:

* A fully polished English version optimized for **documentation**,
* Or a “developer version” optimized for **Replit / GitHub README**,
* Or a compact version for **prompting AI builders**.
